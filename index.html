<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>InformatikLernzettelQ1</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="informatik-lernzettel-q1">Informatik Lernzettel Q1</h1>
<blockquote>
<p>Klausur Nr. 2 - von Jonas M. - code kommt größtenteils von <a href="http://w3schools.com">w3schools.com</a><br>
Bitte beachtet, dass nicht jedes Konzept, das implementiert werden muss, auch in Java Code angegeben ist</p>
</blockquote>
<h2 id="objektorientierte-programmierung">Objektorientierte Programmierung</h2>
<h3 id="was-sind-klassen-methoden-und-attribute">Was sind Klassen, Methoden und Attribute?</h3>
<ul>
<li>Klassen in Java sind Blaupausen für Objekte</li>
<li>Objekte übernehmen die Attribute und Methoden ihrer Klasse</li>
<li>Attribute sind Variablen der Klasse(z.B. int y = 7;)</li>
<li>Methoden sind ein Äquivalent zu Funktionen. Sog. Parameter, also z.B. ein Integer können der Methode beim aufrufen mitgegeben werden</li>
<li>Beispiel: Klasse = Bauanleitung Auto, Objekt = gebautes Auto, Attribut = Farbe des Autos, Methode = lenken</li>
</ul>
<h3 id="uml-klassendiagramme">UML-Klassendiagramme</h3>

<table>
<thead>
<tr>
<th align="center">Klasse</th>
<th align="center">Auto</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Attribute</td>
<td align="center">-y:int = 7</td>
</tr>
<tr>
<td align="center">Methoden</td>
<td align="center">+lenken(winkel:double)</td>
</tr>
</tbody>
</table><ul>
<li>UnifiedModelingLanguarge</li>
<li>visuelle Darstellungsart einer Klasse</li>
<li>Aufbau in die drei Bereiche: Name der Klasse, Attribute der Klasse, Methoden der Klasse</li>
</ul>
<h3 id="sichtbarkeit-von-attributen--methoden-in-uml-diagrammen">Sichtbarkeit von Attributen &amp; Methoden in UML-Diagrammen</h3>
<ul>
<li>
<p>+ =&gt;  public</p>
</li>
<li>
<p>- =&gt; private</p>
</li>
<li>
<p># =&gt; protected</p>

<table>
<thead>
<tr>
<th>#</th>
<th>Klasse</th>
<th>Paket</th>
<th>Unterklasse(selbes Paket)</th>
<th>Unterklasse(anderes Paket)</th>
<th>Welt</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>protected</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>kein Indikator oder package</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>private</td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table></li>
</ul>
<h3 id="geheimnisprinzip">Geheimnisprinzip</h3>
<ul>
<li>Der Zugriff auf die Daten wird aus Sicherheitsgründen und um ungewollte Manipulation zu vermeiden in ihrem Bereich/ in ihrer Sichtbarkeit beschränkt</li>
<li>Stichwort Datenkapselung</li>
</ul>
<h3 id="getset-methoden">get/set-Methoden</h3>
<ul>
<li>
<p>Methoden, die einen privaten Datentyp ausgeben oder überschreiben</p>
</li>
<li>
<p>Beispiel:<br>
<code>public class Klasse {</code><br>
<code>private String name; // private = restricted access</code></p>
<p><code>// get-Methode</code><br>
<code>public String getName() {</code><br>
<code>return name;</code><br>
<code>}</code></p>
<p><code>// set-Methode</code><br>
<code>public void setName(String newName) {</code><br>
<code>Klasse.name = newName;</code><br>
<code>}</code><br>
<code>}</code></p>
</li>
<li>
<p>Vorteile:</p>
<ul>
<li>Bessere Kontrolle von Attributen und Methoden</li>
<li>Option für “read-only” oder “write-only”</li>
<li>Flexibler</li>
<li>höhere Sicherheit der Daten</li>
</ul>
</li>
</ul>
<h3 id="konstruktoren">Konstruktoren</h3>
<ul>
<li>Methode in einer Klasse, die genau so heißt wie sie, und ist public</li>
<li>Bsp.: public Main() { …</li>
<li>Wird beim erstellen eines Objekts der Klasse ausgeführt</li>
<li>Kann z.B. zum initialisieren von Variablen genutzt werden</li>
<li>Kann genutzt werden, wenn gewisse Parameter für das Objekt immer benötigt werden</li>
</ul>
<h3 id="assoziation--aggregation-und-multiplizitäten">Assoziation &amp; Aggregation und Multiplizitäten</h3>
<ul>
<li><a href="http://www.iim.maschinenbau.tu-darmstadt.de/kursunterlagen_archiv/ikt_ws1415/05/Theorie/assoziation_aggregation_komposition.html">http://www.iim.maschinenbau.tu-darmstadt.de/kursunterlagen_archiv/ikt_ws1415/05/Theorie/assoziation_aggregation_komposition.html</a></li>
</ul>
<h2 id="such--und-sortieralgorithmen">Such- und Sortieralgorithmen</h2>
<h3 id="arrays">Arrays</h3>
<ul>
<li>Arrays speichern mehrere Werte des selben Datentyps in einer einzigen Variablen</li>
<li>Deklaration:<br>
<code>String[] autos;</code> Deklariert den Array “cars” des Datentyps String<br>
<code>int[] meineZahlen;</code> Deklariert den Array “meineZahlen” des Datentyps Integer</li>
<li>Initialisierung:<br>
<code>String[] autos = {"Volvo", "BMW", "Ford", "Mazda"};</code> Werte werden dem Array übergeben (gleichzeitige Deklaration und Initialisierung)<br>
<code>meineZahlen[0] = 7;</code> An der Index stelle 0 wird der Wert 7 eingesetzt</li>
</ul>
<h3 id="for-schleifen-mit-arrays">for-Schleifen mit Arrays</h3>
<ul>
<li>
<p>for-Schleifen:</p>
<ul>
<li><code>for (statement 1; statement 2; statement 3) { // code, der ausgeführt wird }</code></li>
<li>s1: einmal beim erstmaligen Aufrufen der Schleife ausgeführt</li>
<li>s2: die Bedingung für die Schleife</li>
<li>s3: wird nach jedem Durchlauf des Codes ausgeführt</li>
<li><code>for (i = 0;i &lt; 9;i++) { //code }</code></li>
</ul>
</li>
<li>
<p>Array ausgeben lassen:<br>
<code>String[] autos = {"Volvo", "BMW", "Ford", "Mazda"};</code><br>
<code>for (int i = cars.length - 1;i &gt;= 0;i--) {</code><br>
<code>System.out.println(cars[i]);</code><br>
<code>}</code><br>
Output: Mazda Ford BMW Volvo</p>
<p><code>String[] autos = {"Volvo", "BMW", "Ford", "Mazda"};</code><br>
<code>for (int i = 0;i &lt; cars.length;i++) {</code><br>
<code>System.out.println(cars[i]);</code><br>
<code>}</code><br>
Output: Volvo BMW Ford Mazda</p>
</li>
<li>
<p>Array anlegen:<br>
<code>int[] numb = new int[10];</code> Gibt dem Array den Wert 0 an den Stellen 0-9<br>
<code>for (int i = 0;i &lt; 10;i++) {</code><br>
<code>numb[i] = i * 2;</code><br>
<code>}</code><br>
numb = {0, 2, 4, 6, 8, 10, 12, 14, 16, 18}</p>
</li>
</ul>
<h3 id="zweidimensionale-arrays">Zweidimensionale Arrays</h3>
<ul>
<li>Array im Array oder Tabelle</li>
<li>zwei Indizes</li>
<li><code>int[][] numb2 = { {1, 2, 3, 4}, {5, 6, 7} };</code><br>
<code>numb2[0][2] == 3</code></li>
<li>Hinweis: Arrays beginnen mit dem Index 0</li>
</ul>
<h3 id="objekte-in-arrays">Objekte in Arrays</h3>
<ul>
<li><code>Fahrrad[] listeFahrraeder = new Fahrrad[5];</code> 5 = länge des Arrays aka. Anzahl möglicher Objekte<br>
<code>listeFahrraeder[0] = new Fahrrad("grün", "cube");</code></li>
</ul>
<h3 id="länge-eines-arrays">Länge eines Arrays</h3>
<ul>
<li>Array.length</li>
<li>listeFahrraeder.length == 5</li>
</ul>
<h3 id="linearer-suchalgorithmus">Linearer Suchalgorithmus</h3>
<ul>
<li>der Array wird ein Element nach dem anderen durchsucht</li>
<li>langsam, aber funktioniert immer</li>
</ul>
<h3 id="binärer-suchalgorithmus">Binärer Suchalgorithmus</h3>
<ul>
<li>kann bei einem geordnetem Array genutzt werden</li>
<li>Wert in der Mitte des Arrays wird mit Suchwert verglichen, wenn kleiner, wird die Hälfte der Hälfte abgezogen, wenn größer hinzugefügt, dann wird wiederholt</li>
<li>log2(n) + 1 = Wiederholungen bis zur Lösung</li>
<li>deutlich schneller, benötigt aber eine Sortierte Liste</li>
</ul>
<h3 id="struktogramme">Struktogramme</h3>
<ul>
<li><a href="https://unterrichten.zum.de/images/3/3d/Struktogramm-Mustererkennung.svg#">https://unterrichten.zum.de/images/3/3d/Struktogramm-Mustererkennung.svg#</a></li>
</ul>
<h3 id="sortieralgorithmen">Sortieralgorithmen</h3>
<ul>
<li>Selection Sort
<ul>
<li>ganzes Array wird durchlaufen, um den kleinsten Wert zu finden</li>
<li>kleinste Wert wird mit Wert an erster Stelle getauscht</li>
<li>verfahren wird wiederholt, nur ohne den ersten Wert</li>
</ul>
</li>
<li>Insertion Sort
<ul>
<li>Erster Wert sortierter Bereich</li>
<li>zweiter Wert wird hinzugefügt, je nachdem, ob er größer oder kleiner ist vor oder nach dem ersten Wert</li>
<li>Sortierter Bereich ist nun der erste und zweite Wert</li>
</ul>
</li>
<li>Bubble Sort
<ul>
<li>Erster und zweiter Wert werden verglichen, wenn nötig getauscht, dann der zweite und dritte usw.</li>
<li>Nach einem Durchlauf ist die größte Zahl am richtigen Ort und das verfahren kann ohne sie wiederholt werden</li>
</ul>
</li>
</ul>
</div>
</body>

</html>
